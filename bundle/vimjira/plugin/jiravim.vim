
if exists('g:loaded_jiravim')
    finish
endif
let g:loaded_jiravim = 1

if version < 700
    echo "jiravim.vim plugin requires Vim 7 or above"
    finish
endif

function! s:get_url() dict
    if self.good
        return self.url
    endif


    if exists('g:jiravim_url')
        let self.url = g:jiravim_url
    else
        let self.url = input('JIRA SOAP Serivce URL: ')
    endif

    return self.url
endfunction

function! s:get_userpass() dict
    " username/password are already verified, don't need to query.
    if self.good
        return {'username': self.username, 'password': self.password}
    endif

    " If the username is wrong in g:jiravim_username, it's the user's job
    " to realize this and fix it.
    if exists('g:jiravim_username')
        let self.username = g:jiravim_username
    else
        let self.username = input('JIRA username: ')
    endif

    let self.password = inputsecret('JIRA password: ')

    return {'username': self.username, 'password': self.password}
endfunction

let s:userpass_keeper = {'good': 0, 'get': function("s:get_userpass")}
let s:url_keeper = {'good': 0, 'get': function("s:get_url")}


"----------------------------------------------------------------------
" Global variables

" TODO: g:jiravim_has_python doesn't really make sense as a global. It should be
" read-only. Consider making a function to query it.
if !exists('g:jiravim_has_python')
    let g:jiravim_has_python = has('python')
    " TODO: Do we need a special 'has' test for python/dyn?
endif

"--------------------------------------------------------------------
" Local variables

let s:jiravim_python_module = 'jiravim'
let s:jiravim_python_module_location = expand("<sfile>:h")
let s:jim_init_flag = 0

"--------------------------------------------------------------------

" Function: s:jim_init()
" Initializes the jiravim plugin. Will early-out if initialization has already
" happened.
"
" Returns: 1 - If initialization succeeded.
"          0 - otherwise.
function! s:jim_init()
    if s:jim_init_flag
        return 1
    endif

    if g:jiravim_has_python
        python import sys

        " TODO: Call to module with username and password to set up SOAP client.
        let userpass = s:userpass_keeper.query_userpass();

    else
        if !s:verify_python_exe()
            return 0
        endif
        let s:jiravim_python_module = '"' . expand(s:jiravim_python_module_location . '/' . s:jiravim_python_module . '.py') . '"'
    endif

    let s:jim_init_flag = 1
    return 1
endfunction

" Function: s:verify_python_exe()
" Tests whether we can call the python executable by simply saying 'python' on
" the command line. This obviously requires the PATH to be set properly.
"
" Returns: 1 - python was successfully executed
"          0 - otherwise. A warning message is printed before returning.
function! s:verify_python_exe()
    let output = system ('python -c "print 123"')
    if output !~ '^123'
        echohl WarningMsg|echomsg 'Python executable not available. Check the PATH environment variable'|echohl None
        return 0
    else
        return 1
    endif
endfunction

" Function: s:soap_execute()
" Call into jiravim.py module (as either a module or script) to execute a
" python function within.
function! s:soap_execute(py_function_name, ...)
    if !s:jim_init()
        return
    endif

    " Quote every argument. In script mode, this ensures a single argument
    " (perhaps with spaces) is treated as a single argument. In module mode,
    " we pass every argument as a string to python.
    let arglist = []
    for pyarg in a:000
        let arglist += ["\"" . pyarg . "\""]
    endfor

    " vimscript generated by python should generate one of two variables: result and
    " fail_type.
    if g:jiravim_has_python
        let pyargs = join(arglist, ',')
        exe 'python ' . s:jiravim_python_module . '.' . a:py_function_name . '(' . pyargs . ')'
        "TODO: execute code generated by python module
    else
        let url = s:url_keeper.get()
        let userpass = s:userpass_keeper.get()
        call extend(arglist, [url, userpass['username'], userpass['password'], a:py_function_name], 0)
        let pyargs = join(arglist, ' ')

        let cmd = 'python ' . s:jiravim_python_module . ' ' . pyargs

        exe system(cmd)
    endif

    " Package up output from python into a single dictionary to return to
    " caller.
    let result_dict = {}
    if exists('result')
        let result_dict['result'] = result
    endif

    if exists('fail_type')
        if fail_type == 'auth'
            let s:userpass_keeper.good = 0
        endif

        if fail_type == 'url'
            let s:url_keeper.good = 0
        endif

        let result_dict['fail_type'] = fail_type
    else
        " Accept username, password, and url as good only when a soap_execute
        " returns without failing.
        let s:userpass_keeper.good = 1
        let s:url_keeper.good = 1
    endif

    return result_dict
endfunction

function! s:construct_buffer_name(command, details)
    if a:command == 'get'
        let name = 'JIRA Issue'
        if has_key(a:details, 'key')
            let name .= ' ' . a:details['key']
        endif
        return name
    else
        return 'JIRAVim Buffer'
    endif
    return ''
endfunction

" Function: s:create_buffer()
" Creates a buffer for jiravim to populate with information. Sets up the
" filetype of the buffer and the buffer name as well setting up other buffer
" variables. The cursor is placed in the new buffer.
"
" command - Should be one of the supporte jiravim commands
" details - A dictionary with information for constructing the buffer name.
"           The keys required depend on the value of a:command.
function! s:create_buffer(command, details)
    rightbelow new
    setlocal buftype=nofile
    setlocal noswapfile
    let &filetype = 'jira' . a:command
    let name = s:construct_buffer_name(a:command, a:details)

    if strlen(name) > 0
        silent noautocmd file `=name`
    endif
endfunction

" Function: s:jim_get_issue()
" Entry point from the user for getting issue information from JIRA and
" putting it in a result buffer.
" key - The JIRA issue key (i.e. ID) to query
function! s:jim_get_issue(key)
    " For now we hard-code the fields we want to display.
    let result = s:soap_execute("get_issue", a:key, '[''summary'', ''description'', ''assignee'', ''fixVersions'', ''worklogs'', ''comments'']')
    if !has_key(result, 'result')
        return
    endif

    let result = result['result']

    call s:create_buffer('get', {'key' : a:key})

    silent put!=a:key.': '.result['summary']
    normal j
    silent put!=''
    normal j
    silent put!='Fix Version:  '.join(result['fixVersions'], ', ')
    normal j
    silent put!='Assignee:     '.result['assignee']
    normal j
    silent put!=''
    normal j
    silent put!='Description:'
    normal j
    let startline=line('$')
    setlocal textwidth=80
    silent put!=result['description']
    execute 'normal gq' . startline . 'gg'
    setlocal tw=0

    " Worklogs, if any exist.
    normal j
    silent put!=''
    normal j
    let section_start = line('$')
    silent put!='Worklogs ' . repeat('-', 30)
    normal j

    if has_key(result, 'worklogs') && len(result['worklogs']) > 0
        for log in result['worklogs']
          silent put!=''
          normal j
          let header = log['author'] . ' ' . log['timeSpent'] . ' ' . log['created']
          silent put!=header
          normal j

          " Format comment text
          let text_start = line('$')
          setlocal textwidth=80
          silent put!=log['comment']
          execute 'normal gq' . text_start . 'gg'
          setlocal tw=0
          normal j
        endfor

        " Create fold around all worklogs
        normal k
        execute 'normal zf' . section_start . 'gg'
    else
        silent put!='No work logged for this issue'
        normal j
    endif

    " Comments if any
    normal j
    silent put!=''
    normal j
    let section_start = line('$')
    echo section_start
    silent put!='Comments ' . repeat('-', 30)
    normal j

    if has_key(result, 'comments') && len(result['comments']) > 0
        for log in result['comments']
          silent put!=''
          normal j
          let header = log['author'] . ' ' . log['created']
          silent put!=header
          normal j
          let text_start = line('$')

          " Format comment text
          setlocal textwidth=80
          silent put!=log['body']
          execute 'normal gq' . text_start . 'gg'
          setlocal tw=0
          normal j
        endfor

        " Create fold to collapse all comments
        normal k
        execute 'normal zf' . section_start . 'gg'
    else
        silent put!='No comments for this issue'
        normal j
    endif

    normal gg


endfunction

com! -nargs=1 JIMGet call s:jim_get_issue(<f-args>)

